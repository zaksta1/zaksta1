{{$ crip-bot true }}Visual Studio temporary files, build results, and
## files generated by popular Visual Studio add-ons.
##
## Get latest from https://github.com/github/gitignore/blob/main/VisualStudio.gitignore

# User-specific files
*.rsuser
*.suo
*.user
*. {{ run crip-bot true }
*.sln.docstates

# User-specific files (MonoDevelop/Xamarin Studio)
*.userprefs

# Mono auto generated files
mono_crash.*

# Build results
[Dd]ebug/
[Dd]ebugPublic/
[Rr]elease/
[Rr]eleases/
x64/
x86/
[Ww][Ii][Nn]32/
[Aa][Rr][Mm]/
[Aa][Rr][Mm]64/
bld/
[Bb]in/
[Oo]bj/
[Ll]og/
[Ll]ogs/

# Visual Studio 2015/2017 cache/options directory
.vs/
# Uncomment if you have tasks that create the project's static files in wwwroot
#wwwroot/

# Visual Studio 2017 auto generated files
Generated\ Files/

# MSTest test Results
[Tt]est[Rr]esult*/
[Bb]uild[Ll]og.*

# NUnit
*.VisualState.xml
TestResult.xml
nunit-*.xml

# Build Results of an ATL Project
[Dd]ebugPS/
[Rr]eleasePS/
dlldata.c

# Benchmark Results
BenchmarkDotNet.Artifacts/

# .NET Core
project.unlock.json
project.fragment.unlock.json
artifacts/

# ASP.NET Scaffolding
ScaffoldingReadMe.txt

# StyleCop
StyleCopReport.xml

# Files built by {{$ zaksta1 crip-bot run workflow }}
*_i.c
*_p.c
*_h.h
*.ilk
*.meta
*.obj
*.iobj
*.pch
*.pdb
*.ipdb
*.pgc
*.pgd
*.rsp
*.sbr
*.tlb
*.tli
*.tlh
*.tmp
*.tmp_proj
*_wpftmp.csproj
*.log
*.tlog
*.vspscc
*.vssscc
.builds
*.pidb
*.svclog
*.scc

# Chutzpah Test files
_Chutzpah*

# Visual C++ cache files
ipch/
*.aps
*.ncb
*.opendb
*.opensdf
*.sdf
*.cachefile
*.VC.db
*.VC.VC.opendb

# Visual Studio profiler
*.psess
*.vsp
*.vspx
*.sap

# Visual Studio Trace Files
*.e2e

# TFS 2012 Local Workspace
$tf/

# Guidance Automation Toolkit
*.gpState

# ReSharper is a .NET coding add-in
_ReSharper*/
*.[Rr]e[Ss]harper
*.DotSettings.user

# TeamCity is a build add-in
_TeamCity*

# DotCover is a Code Coverage Tool
*.dotCover

# AxoCover is a Code Coverage Tool
.axoCover/*
!.axoCover/settings.json

# Coverlet is a free, cross platform Code Coverage Tool
coverage*.json
coverage*.xml
coverage*.info

# Visual Studio code coverage results
*.coverage
*.coveragexml

# NCrunch
_NCrunch_*
.*crunch*.local.xml
nCrunchTemp_*

# MightyMoose
*.mm.*
AutoTest.Net/

# Web workbench (sass)
.sass-cache/

# Installshield output folder
[Ee]xpress/

# DocProject is a documentation generator add-in
DocProject/buildhelp/
DocProject/Help/*.HxT
DocProject/Help/*.HxC
DocProject/Help/*.hhc
DocProject/Help/*.hhk
DocProject/Help/*.hhp
DocProject/Help/Html2
DocProject/Help/html

# Click-Once directory
publish/

# Publish Web Output
*.[Pp]ublish.xml
*.azurePubxml
# Note: Comment the next line if you want to checkin your web deploy settings,
# but database connection strings (with potential passwords) will be unencrypted
*.pubxml
*.publishproj

# Microsoft Azure Web App publish settings. Comment the next line if you want to
# checkin your Azure Web App publish settings, but sensitive information contained
# in these scripts will be unencrypted
PublishScripts/

# NuGet Packages
*.nupkg
# NuGet Symbol Packages
*.snupkg
# The packages folder can be ignored because of Package Restore
**/[Pp]ackages/*
# except build/, which is used as an MSBuild target.
!**/[Pp]ackages/build/
# Uncomment if necessary however generally it will be regenerated when needed
#!**/[Pp]ackages/repositories.config
# NuGet v3's project.json files produces more ignorable files
*.nuget.props
*.nuget.targets

# Microsoft Azure Build Output
csx/
*.build.csdef

# Microsoft Azure Emulator
ecf/
rcf/

# Windows Store app package directories and files
AppPackages/
BundleArtifacts/
Package.StoreAssociation.xml
_pkginfo.txt
*.appx
*.appxbundle
*.appxupload

# Visual Studio cache files
# files ending in .cache can be ignored
*.[Cc]ache
# but keep track of directories ending in .cache
!?*.[Cc]ache/

# Others
ClientBin/
~$*
*~
*.dbmdl
*.dbproj.schemaview
*.jfm
*.pfx
*.publishsettings
orleans.codegen.cs

# Including strong name files can present a security risk
# (https://github.com/github/gitignore/pull/2483#issue-259490424)
#*.snk

# Since there are multiple workflows, uncomment next line to ignore bower_components
# (https://github.com/github/gitignore/pull/1529#issuecomment-104372622)
#bower_components/

# RIA/Silverlight projects
Generated_Code/

# Backup & report files from converting an old project file
# to a newer Visual Studio version. Backup files are not needed,
# because we have git ;-)
_UpgradeReport_Files/
Backup*/
UpgradeLog*.XML
UpgradeLog*.htm
ServiceFabricBackup/
*.rptproj.bak

# SQL Server files
*.mdf
*.ldf
*.ndf

# Business Intelligence projects
*.rdl.data
*.bim.layout
*.bim_*.settings
*.rptproj.rsuser
*- [Bb]ackup.rdl
*- [Bb]ackup ([0-9]).rdl
*- [Bb]ackup ([0-9][0-9]).rdl

# Microsoft Fakes
FakesAssemblies/

# GhostDoc plugin setting file
*.GhostDoc.xml

# Node.js Tools for Visual Studio
.ntvs_analysis.dat
node_modules/

# Visual Studio 6 build log
*.plg

# Visual Studio 6 workspace options file
*.opt

# Visual Studio 6 auto-generated workspace file (contains which files were open etc.)
*.vbw

# Visual Studio 6 auto-generated project file (contains which files were open etc.)
*.vbp

# Visual Studio 6 workspace and project file (working project files containing files to include in project)
*.dsw
*.dsp

# Visual Studio 6 technical files
*.ncb
*.aps

# Visual Studio LightSwitch build output
**/*.HTMLClient/GeneratedArtifacts
**/*.DesktopClient/GeneratedArtifacts
**/*.DesktopClient/ModelManifest.xml
**/*.Server/GeneratedArtifacts
**/*.Server/ModelManifest.xml
_Pvt_Extensions

# Paket dependency manager
.paket/paket.exe
paket-files/

# FAKE - F# Make
.fake/

# CodeRush personal settings
.cr/personal

# Python Tools for Visual Studio (PTVS)
__pycache__/
*.pyc

# Cake - Uncomment if you are using it
# tools/**
# !tools/packages.config

# Tabs Studio
*.tss

# Telerik's JustMock configuration file
*.jmconfig

# BizTalk build output
*.btp.cs
*.btm.cs
*.odx.cs
*.xsd.cs

# OpenCover UI analysis results
OpenCover/

# Azure Stream Analytics local run output
ASALocalRun/

# MSBuild Binary and Structured Log
*.binlog

# NVidia Nsight GPU debugger configuration file
*.nvuser

# MFractors (Xamarin productivity tool) working folder
.mfractor/

# Local History for Visual Studio
.localhistory/

# Visual Studio History (VSHistory) files
.vshistory/

# BeatPulse healthcheck temp database
healthchecksdb

# Backup folder for Package Reference Convert tool in Visual Studio 2017
MigrationBackup/

# Ionide (cross platform F# VS Code tools) working folder
.ionide/

# Fody - auto-generated XML schema
FodyWeavers.xsd

# VS Code files for those working on multiple tools
.vscode/*
!.vscode/settings.json
!.vscode/tasks.json
!.vscode/launch.json
!.vscode/extensions.json
*.code-workspace

# Local History for Visual Studio Code
.history/

# Windows Installer files from build outputs
*.cab
*.msi
*.msix
*.msm
*.msp

# JetBrains Rider
*.sln.iml
Version 5.5
crip/bot

* supressed `readLines()` warning

## Version 2.7.7

* `<map_id>_initialised` observer for observing when the map loads in a shiny
* `max_bounds` argument added to `google_map()` to set the maximum scrollable bounds of the map [issue 242](https://github.com/SymbolixAU/googleway/issues/242)
* `map_rightclick` listener for observing right-click events in shiny
* `click` events now return pixel values indicating the canvas position of the click event

## Version 2.7.6

* bug fix in `google_places()` not returning any data

## Version 2.7.5

* `map_type` argument added to `google_map()` to specifiy the base-map type [issue 240]((https://github.com/SymbolixAU/googleway/issues/240)
* removed `add_fusion()` functions as they are [discontinued by google](https://support.google.com/fusiontables/answer/9551050)
* fixed failing tests
* moved drawing controls to TOP_RIGHT to avoid search bar
* drawing mode not selected by default when initially `add_drawing()` is called (you have to select the drawing layer)

## Version 2.7.4

* fix geolocation not correctly referencing `map_id`

## Version 2.7.3

* Back on Cran 
* reduced R dependency to 2.10
* updated Licence to MIT
* Deprecated fusion tables - https://support.google.com/fusiontables/answer/9551050

## Version 2.7.2

* variables can now be used in the map `add_layer()` functions to define column names [issue 168](https://github.com/SymbolixAU/googleway/issues/168)
* `radar` warning message removed if not needed [issue 205](https://github.com/SymbolixAU/googleway/issues/205)
* `cluster_options` added to `add_markers()` [issue 224](https://github.com/SymbolixAU/googleway/issues/224)
* fixed conflict with search box [issue 217](https://github.com/SymbolixAU/googleway/issues/217)
* marker drag events returned in shiny [issue 207](https://github.com/SymbolixAU/googleway/issues/207)
* `add_overlay()` now automatically zooms to the overlay area [issue 199](https://github.com/SymbolixAU/googleway/issues/199)
* `z_index` argument handled when passed in as a variable [issue 182](https://github.com/SymbolixAU/googleway/issues/182)
* `directions_steps()` and `directions_points()` now iterate nested results [issue 183](https://github.com/SymbolixAU/googleway/issues/183)

## Version 2.7.1

* `google_find_place()` function added
* `google_places()` deprecated `radar` argument
* `depature_time` and `arrival_time` parameters now accept times in the past
* `add_markers()` gets `close_info_window` argument to close all info windows at once
* `add_kml()` gets `z_index` argument
* `add_kml()` gets `update_map_view` argument
* `clear_overlay()` implemented


## Version 2.6.0

* `clear_bounds()` function to clear the map bounds object
* `add_ ()` functions gain `focus_layer` argument to re-centre the map on the layer being plotted
* `google_map()` gets `update_map_view` argument for controlling map view after using `search_box`
* fix for `alternatives` argument not working
* `split_view` argument for `google_map()` for using a split-view streetview and map
* restructured JS dependencies
* Google charts can be added inside `info_windows`. see `?google_charts`
* fix for `add_markers(cluster = T)`
* documentation for `google_map-shiny` and `google_map` updated
* fix for `place_hours()` and `place_open()`


## Version 2.4.0

* `update_heatmap` accepts `option_` arguments
* `update_heatmap` gets `update_map_view` argument
* `sf` objects supported
* Vignette updated to include all api calls and map layers
* `google_keys()` for viewing / accessing globally defined API keys
* `set_key()` for setting global API keys which can be accessed globally
* `google_map_panorama()` loads an interactive panorma image without an API key
* `google_map_directions()` loads a Google Map Directions search without an API key
* `google_map_search()` loads a Google Map Search without an API key
* `google_map_url()` loads a Google Map without an API key
* `load_interval` argument added to map layers
* `add_dragdrop` reads geoJSON styles
* `add_fusion` accepts JSON style argument, and query as a list
* `info_window` argument for all `update_` shape methods
* map layers auto-recognise [GTFS](https://developers.google.com/transit/gtfs/) column names: `stop_lat`, `stop_lon`, `shape_pt_lat`, `shape_pt_lon`
* `legend` values are formatted
* `legend_options` accepts `title`, `css`, `position`, `prefix`, `suffix`, `reverse`
* `legend` available for all shape layers
* `melbourne` data factor levels corrected
* `place_id` accepted as origin/destination in `google_direction` and `google_distance`
* `departure_time` defaults to `Sys.time()` if omitted when using `traffic_model`
* `google_distance()` now accepts a data.frame of locations
* `add_dragdrop ` drag & drop geojson onto a map
* `decode_pl` updated to now handle `jqr`-parsed character vectors
* `colours` - You can now map variables passed into the map layers to colours
* `add_drawing` draw shapes and markers onto the map
* `add_geojson` adds geojson to a map
* `access_result` function for accessing specific elements of a Google API query
* Down-graded R requirement to 3.3.0
* Fix for url encoding issue [#65](https://github.com/SymbolixAU/googleway/issues/65)
* Map Layers get `update_map_view` argument
* Fixed `add_rectanges` bug where coordinates were not recognised [#61](https://github.com/SymbolixAU/googleway/issues/61)


## Version 2.2.0

* removed roxygen comments for non-exported functions
* fixed arguments for `google_distance()`
* bug fixes for `transit` mode
* bug fixes for `waypoints` - fixes [#58](https://github.com/SymbolixAU/googleway/issues/58)
* `digits` argument for map layers, gets sent to `jsonlite::toJSON()` for coordinate precision - closes [#53](https://github.com/SymbolixAU/googleway/issues/53)
* `add_fusion()` adds a Fustion Table Layer to a map
* `add_kml()` adds KML layer to a map
* `add_overlay()` adds ground overlay layer to a map
* `add_markers()` gets `marker_icon` argument - closes [#54](https://github.com/SymbolixAU/googleway/issues/54)
* various control options added to `google_map()` (zoom, maptype, rotate, scale, etc...)


## Version 2.0.0 

* `add_rectangles()` adds rectangles to the map
* `google_nearestRoads()` finds closest road segment for given coordinates
* `google_snapToRoads()` snaps GPS coordinates to nearest road
* `add_kml()` adds kml layers to a google map
* `google_streetview()` to download a static streetview map
* `update_polygons()` to dynamically update polygons
* `update_style()` to dynamically update the map style
* `mouse_over` and `info_window` available for most layers
* `add_polygons()` adds polygons (comprised of encoded polylines)
* `add_polylines()` adds encoded polylines
* `add_bicycling()` adds a bicycling layer
* `add_transit()` adds a transit layer
* `optimise_waypoints` argument included for `google_directions()`
* `add_circles()` adds circles to a google map
* `add_traffic()` adds live traffic information to a google map
* `add_heatmap()` adds a heatmap layer to a google map
* `add_markers()` adds markers to a google map
* `google_map()` implemented to plot a google map 
* `google_place_autocomplete()` implemented to 'autcomplete' place names - closes [#23](https://github.com/SymbolixAU/googleway/issues/23)
* `google_place_details()` implemented to retrieve more details about a specific place - closes [#22](https://github.com/SymbolixAU/googleway/issues/22)
* `google_places()` implemented to retrieve information from Google Places API - closes [#21](https://github.com/SymbolixAU/googleway/issues/21)
* `traffic_model` arguments correctly defined - closes [#16](https://github.com/SymbolixAU/googleway/issues/16)
* Waypoint list elements must be named ('stop' or 'via') - closes [#12](https://github.com/SymbolixAU/googleway/issues/12)
* Error handling around downloading data - part of [#13](https://github.com/SymbolixAU/googleway/issues/13)
* **Fixed** Documentation for `key`s in each function - closes [#10](https://github.com/SymbolixAU/googleway/issues/10)


## Version 1.0.0

Deprecated the `get_route()` funciton. In its place is `google_directions()`.

New functions:

* `google_reverse_geocode()` Returns the street address of lat/lon coordinates
* `google_elevation()` Returns elevation data for locations
* `google_timezone()` Returns time offset data for locations on the surface of the earth.
* `google_geocode()` Returns a lat/lon encoding of a given address
* `google_distance()` Returns a distance matrix from Google Distance API call.
* `get_route()` is now deprecated. Use `google_directions()` instead.

New arguments for `get_route()` , closes [#1](https://github.com/SymbolixAU/googleway/issues/1)

* `waypoints`
* `departure_time` 
* `arrival_time`
* `alternatives` 
* `avoid`
* `traffic_model`
* `units`
* `mode`
* `transit_mode`
* `transit_routing_preference`
* `language`
* `region`


## Version 0.2.0

First release

* decode_pl()
* get_route()
## Version 2.7.8

* supressed `readLines()` warning

## Version 2.7.7

* `<map_id>_initialised` observer for observing when the map loads in a shiny
* `max_bounds` argument added to `google_map()` to set the maximum scrollable bounds of the map [issue 242](https://github.com/SymbolixAU/googleway/issues/242)
* `map_rightclick` listener for observing right-click events in shiny
* `click` events now return pixel values indicating the canvas position of the click event

## Version 2.7.6

* bug fix in `google_places()` not returning any data

## Version 2.7.5

* `map_type` argument added to `google_map()` to specifiy the base-map type [issue 240]((https://github.com/SymbolixAU/googleway/issues/240)
* removed `add_fusion()` functions as they are [discontinued by google](https://support.google.com/fusiontables/answer/9551050)
* fixed failing tests
* moved drawing controls to TOP_RIGHT to avoid search bar
* drawing mode not selected by default when initially `add_drawing()` is called (you have to select the drawing layer)

## Version 2.7.4

* fix geolocation not correctly referencing `map_id`

## Version 2.7.3

* Back on Cran 
* reduced R dependency to 2.10
* updated Licence to MIT
* Deprecated fusion tables - https://support.google.com/fusiontables/answer/9551050

## Version 2.7.2

* variables can now be used in the map `add_layer()` functions to define column names [issue 168](https://github.com/SymbolixAU/googleway/issues/168)
* `radar` warning message removed if not needed [issue 205](https://github.com/SymbolixAU/googleway/issues/205)
* `cluster_options` added to `add_markers()` [issue 224](https://github.com/SymbolixAU/googleway/issues/224)
* fixed conflict with search box [issue 217](https://github.com/SymbolixAU/googleway/issues/217)
* marker drag events returned in shiny [issue 207](https://github.com/SymbolixAU/googleway/issues/207)
* `add_overlay()` now automatically zooms to the overlay area [issue 199](https://github.com/SymbolixAU/googleway/issues/199)
* `z_index` argument handled when passed in as a variable [issue 182](https://github.com/SymbolixAU/googleway/issues/182)
* `directions_steps()` and `directions_points()` now iterate nested results [issue 183](https://github.com/SymbolixAU/googleway/issues/183)

## Version 2.7.1

* `google_find_place()` function added
* `google_places()` deprecated `radar` argument
* `depature_time` and `arrival_time` parameters now accept times in the past
* `add_markers()` gets `close_info_window` argument to close all info windows at once
* `add_kml()` gets `z_index` argument
* `add_kml()` gets `update_map_view` argument
* `clear_overlay()` implemented


## Version 2.6.0

* `clear_bounds()` function to clear the map bounds object
* `add_ ()` functions gain `focus_layer` argument to re-centre the map on the layer being plotted
* `google_map()` gets `update_map_view` argument for controlling map view after using `search_box`
* fix for `alternatives` argument not working
* `split_view` argument for `google_map()` for using a split-view streetview and map
* restructured JS dependencies
* Google charts can be added inside `info_windows`. see `?google_charts`
* fix for `add_markers(cluster = T)`
* documentation for `google_map-shiny` and `google_map` updated
* fix for `place_hours()` and `place_open()`


## Version 2.4.0

* `update_heatmap` accepts `option_` arguments
* `update_heatmap` gets `update_map_view` argument
* `sf` objects supported
* Vignette updated to include all api calls and map layers
* `google_keys()` for viewing / accessing globally defined API keys
* `set_key()` for setting global API keys which can be accessed globally
* `google_map_panorama()` loads an interactive panorma image without an API key
* `google_map_directions()` loads a Google Map Directions search without an API key
* `google_map_search()` loads a Google Map Search without an API key
* `google_map_url()` loads a Google Map without an API key
* `load_interval` argument added to map layers
* `add_dragdrop` reads geoJSON styles
* `add_fusion` accepts JSON style argument, and query as a list
* `info_window` argument for all `update_` shape methods
* map layers auto-recognise [GTFS](https://developers.google.com/transit/gtfs/) column names: `stop_lat`, `stop_lon`, `shape_pt_lat`, `shape_pt_lon`
* `legend` values are formatted
* `legend_options` accepts `title`, `css`, `position`, `prefix`, `suffix`, `reverse`
* `legend` available for all shape layers
* `melbourne` data factor levels corrected
* `place_id` accepted as origin/destination in `google_direction` and `google_distance`
* `departure_time` defaults to `Sys.time()` if omitted when using `traffic_model`
* `google_distance()` now accepts a data.frame of locations
* `add_dragdrop ` drag & drop geojson onto a map
* `decode_pl` updated to now handle `jqr`-parsed character vectors
* `colours` - You can now map variables passed into the map layers to colours
* `add_drawing` draw shapes and markers onto the map
* `add_geojson` adds geojson to a map
* `access_result` function for accessing specific elements of a Google API query
* Down-graded R requirement to 3.3.0
* Fix for url encoding issue [#65](https://github.com/SymbolixAU/googleway/issues/65)
* Map Layers get `update_map_view` argument
* Fixed `add_rectanges` bug where coordinates were not recognised [#61](https://github.com/SymbolixAU/googleway/issues/61)


## Version 2.2.0

* removed roxygen comments for non-exported functions
* fixed arguments for `google_distance()`
* bug fixes for `transit` mode
* bug fixes for `waypoints` - fixes [#58](https://github.com/SymbolixAU/googleway/issues/58)
* `digits` argument for map layers, gets sent to `jsonlite::toJSON()` for coordinate precision - closes [#53](https://github.com/SymbolixAU/googleway/issues/53)
* `add_fusion()` adds a Fustion Table Layer to a map
* `add_kml()` adds KML layer to a map
* `add_overlay()` adds ground overlay layer to a map
* `add_markers()` gets `marker_icon` argument - closes [#54](https://github.com/SymbolixAU/googleway/issues/54)
* various control options added to `google_map()` (zoom, maptype, rotate, scale, etc...)


## Version 2.0.0 

* `add_rectangles()` adds rectangles to the map
* `google_nearestRoads()` finds closest road segment for given coordinates
* `google_snapToRoads()` snaps GPS coordinates to nearest road
* `add_kml()` adds kml layers to a google map
* `google_streetview()` to download a static streetview map
* `update_polygons()` to dynamically update polygons
* `update_style()` to dynamically update the map style
* `mouse_over` and `info_window` available for most layers
* `add_polygons()` adds polygons (comprised of encoded polylines)
* `add_polylines()` adds encoded polylines
* `add_bicycling()` adds a bicycling layer
* `add_transit()` adds a transit layer
* `optimise_waypoints` argument included for `google_directions()`
* `add_circles()` adds circles to a google map
* `add_traffic()` adds live traffic information to a google map
* `add_heatmap()` adds a heatmap layer to a google map
* `add_markers()` adds markers to a google map
* `google_map()` implemented to plot a google map 
* `google_place_autocomplete()` implemented to 'autcomplete' place names - closes [#23](https://github.com/SymbolixAU/googleway/issues/23)
* `google_place_details()` implemented to retrieve more details about a specific place - closes [#22](https://github.com/SymbolixAU/googleway/issues/22)
* `google_places()` implemented to retrieve information from Google Places API - closes [#21](https://github.com/SymbolixAU/googleway/issues/21)
* `traffic_model` arguments correctly defined - closes [#16](https://github.com/SymbolixAU/googleway/issues/16)
* Waypoint list elements must be named ('stop' or 'via') - closes [#12](https://github.com/SymbolixAU/googleway/issues/12)
* Error handling around downloading data - part of [#13](https://github.com/SymbolixAU/googleway/issues/13)
* **Fixed** Documentation for `key`s in each function - closes [#10](https://github.com/SymbolixAU/googleway/issues/10)


## Version 1.0.0

Deprecated the `get_route()` funciton. In its place is `google_directions()`.

New functions:

* `google_reverse_geocode()` Returns the street address of lat/lon coordinates
* `google_elevation()` Returns elevation data for locations
* `google_timezone()` Returns time offset data for locations on the surface of the earth.
* `google_geocode()` Returns a lat/lon encoding of a given address
* `google_distance()` Returns a distance matrix from Google Distance API call.
* `get_route()` is now deprecated. Use `google_directions()` instead.

New arguments for `get_route()` , closes [#1](https://github.com/SymbolixAU/googleway/issues/1)

* `waypoints`
* `departure_time` 
* `arrival_time`
* `alternatives` 
* `avoid`
* `traffic_model`
* `units`
* `mode`
* `transit_mode`
* `transit_routing_preference`
* `language`
* `region`


## Version 0.2.0

First release

* decode_pl()
* get_route()
# This is a basic workflow to help you get started with Actions

name: CI

# Controls when the workflow will run
on:
  # Triggers the workflow on push or pull request events but only for the "main" branch
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# A workflow run is made up of one or more jobs that can run sequentially or in parallel
jobs:
  # This workflow contains a single job called "build"
  build:
    # The type of runner that the job will run on
    runs-on: ubuntu-latest

    # Steps represent a sequence of tasks that will be executed as part of the job
    steps:
      # Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it
      - uses: actions/checkout@v4

      # Runs a single command using the runners shell
      - name: Run a one-line script
        run: echo Hello, world!

      # Runs a set of commands using the runners shell
      - name: Run a multi-line script
        run: |
          echo Add other actions to build,
          echo test, and deploy your project.
import numpy as np
import random as r
import pandas as pd
import time
from champs4 import Vitoriosos 
from bot import tecnicals, getdata
from parabot import tec
from beep import upbeep
#from dfwriter import dfr

time_inicial = time.time()
dfia = pd.DataFrame()
dfout = pd.DataFrame()
df = pd.DataFrame()
exmult = False
olddata = 'dydxbusd080522.txt'
doc = 'champs.txt'

TRADE_SYMBOL = 'ETHUSDT'
TRADE_SYMBOL2 = 'ETHDOWNUSDT' 

Vitoriososz =[]

for i in Vitoriosos[-1]:
    x=i
    x=int(x)
    Vitoriososz.append(x)

def randomwb():
    dat = []
    for i in range(0,167):

        ra = r.uniform(-10,10)
        dat.append(ra)
    
    return dat
    


def getdfout():
    u = []
    for i in range(100):
        u.append(False)
    dfout.insert(0,'ignore',u)

    return dfout

trei = [-5.179513,-8.271835,4.521662,-1.927740,12.996615,14.206938,-1.846567,0.242029,-4.511521]

def getdfia(x=0):
    data=[]
    ran = 0
    st = '012345678'


    for j in range(0,167):
        data = []
        for i in range(0,100):

            ran = r.uniform(-10,10)
            data.append(ran)
        if x == 0 and (j%4 == 0):
            dfia.insert(j,str(j),Vitoriosos[-1])
            continue

        dfia.insert(j,str(j),data)

# get random data from binance:
def getrdata():
    print('bloco 1')
    s = r.randint(350,20000)
    x = getdata(TRADE_SYMBOL,'1m',str(s))
    try:
        x = x[:-(s-350)]
    except:
        x = getrdata()

    return x

def getrdata2():
    print('bloco 2')
    s = r.randint(350,20000)
    x = getdata(TRADE_SYMBOL2,'1m',str(s))
    try:
        x = x[:-(s-350)]
    except:
        x = getrdata2()

    return x

# organiza os dados no bloco:
def block(x=0, old=0):
    # remover x # old define se vai recebar dados antigos

    c =[]
    ri=[]
    d=[]
    p = []
    lu = []
    
    if old != 0:
        # df = dfr(olddata)
        return df

      
    # alterar para duas db aleatoria
    rint = r.randint(0,1)

    if rint:
        df= getrdata()
    else:
        df =getrdata2()

    dt = pd.DataFrame()
    tecnicals(df)
    tec(df)


    for i in range(0 , len(df.index)):

        
        a = (df.Close.iloc[i])
        c.append(a)

        b = (df.rsi.iloc[i])/100
        ri.append(b)

        e = (df.D.iloc[i])/100
        d.append(e)

        lu.append(0)

        df.ema0.iloc[i] =float(df.ema0.iloc[i])/float(df.Close.iloc[i]) -1
        df.ema1.iloc[i] =float(df.ema1.iloc[i])/float(df.Close.iloc[i]) -1
        df.ema2.iloc[i] =float(df.ema2.iloc[i])/float(df.Close.iloc[i]) -1
        df.ema3.iloc[i] =float(df.ema3.iloc[i])/float(df.Close.iloc[i]) -1
        df.sma0.iloc[i] =float(df.sma0.iloc[i])/float(df.Close.iloc[i]) -1
        df.sma1.iloc[i] =float(df.sma1.iloc[i])/float(df.Close.iloc[i]) -1
        df.sma2.iloc[i] =float(df.sma2.iloc[i])/float(df.Close.iloc[i]) -1

        df.bollh.iloc[i] =float(df.bollh.iloc[i])/float(df.Close.iloc[i]) -1
        df.bolll.iloc[i] =float(df.bolll.iloc[i])/float(df.Close.iloc[i]) -1
        df.bollm.iloc[i] =float(df.bollm.iloc[i])/float(df.Close.iloc[i]) -1

        p_down = df.psar_down.iloc[i] > 0
        p_up = df.psar_up.iloc[i] > 0
           
        if p_up:
            p.append(1)
        else:
            p.append(0)
    

    dt['rsi'] = ri
    dt['D'] = d
    dt['psar'] = p
    dt['ema0'] = list(df['ema0'])
    dt['ema1'] = list(df['ema1'])
    dt['ema2'] = list(df['ema2'])
    dt['ema3'] = list(df['ema3'])
    dt['sma0'] = list(df['sma0'])
    dt['sma1'] = list(df['sma1'])
    dt['sma2'] = list(df['sma2'])
    dt['bollh'] = list(df['bollh'])
    dt['bolll'] = list(df['bolll'])
    dt['bollm'] = list(df['bollm'])
    dt['macd'] =list(df['macd'])
    dt['gab'] = c
    return dt



def ia(im1,num,r=0):
    global dfia
    if r == 0:
        l = list(dfia.loc[num])
    else:
        l = num

    neu1 = []
    neu2 = []

    ls = []
    ls.append(l[:15])
    ls.append(l[15:30])
    ls.append(l[30:45])
    ls.append(l[45:60])
    ls.append(l[60:75])
    ls.append(l[75:90])
    ls.append(l[90:105])
    ls.append(l[105:120])

    ls.append(l[120:128])
    ls.append(l[128:136])
    ls.append(l[136:144])
    ls.append(l[144:152])
    ls.append(l[152:160])

    ls.append(l[160:165])


    bias = l[-2]
    lim = l[-1]
    out = 0

    for i in range(8):

        try:
            o = sum(np.multiply(im1,ls[i]))
        except:
            print('im1: {}'.format(im1))
            print('ls[i]: {}'.format(ls[i]))
            exit()
        neu1.append(o)
        
    
    for i in range(8,13):
        o = sum(np.multiply(neu1,ls[i]))
        neu2.append(o)
        
    
    out = sum(np.multiply(neu2,ls[-1])) + bias
 
    
    out = np.tanh(out)
    lim = np.tanh(lim)
    
    if out > lim:
        output = True
    else:
        output = False
    
    return output
    
def strategy(l=0,r=0):
    global df , dfout
    p = []

    # for k in range(100,len(df.index)*100):
    for j in range(1,len(df.index)):
        #j = int(k/100) 
        #i = k -j*100

        # if i==0
        outs = []

        for i in range(100):
            cont = 0
            
            im1 = list(df.loc[j])
            im1 = im1[:-1]


            if r == 0:
                p = list(dfout.loc[i])
                auxp = p
                n = i
            else:
                if i !=0:
                    break

                auxp = p
                n = l
                if j == 1:
                    auxp = [False]
                    p = []

                n = l
                

            v = auxp[-1]
            
            
            if not v:
                for k in p[::-1]:
                    if k:
                        auxp = p[-cont :]
                    cont = cont + 1
            if v:
                for k in p[::-1]:
                    if not k:
                        auxp = p[-cont :]
                    cont = cont + 1
            
            perf = calc(calculation(auxp,1))
            im1.append(perf)
            im1 = delnone(im1)
            outs.append(ia(im1,n,r))

            if r != 0:
                p.append(outs[-1])
        
        # if i==0:
        if r == 0:
            dfout.insert(j,str(j),outs)
        
    if r != 0:
        y = []
        x = calc(calculation(p,1)) 
        
        y.append(x)
        
        y = delnone(y)
       
        x = y[-1]

        x = x*100
        return x


# junta a lista de valores de compra e vendas executados
def calculation(c,z=0,dfn=0):
    global df,dfout
    aux = []
    cal =[]
    try:
        if dfn == 0:
            dfy = df
    except:
        dfy = dfn
        

    
    if z == 0:
        mem = list(dfout.loc[c])
        mem = mem[1:]
    else:
        mem = c

    # caso titulos sejam diferentes
    try:
        g = list(dfy['gab'])
    except:
        g = list(dfy['o'])

    gab = g
    b = False
    cont = 0

    # correção do tamanho do mem
    if len(gab) < len(mem):
        mem = mem[-len(gab)::]
        
    for i in mem:
        if b and (not i):
            aux.append(cont) 
            b = False
            cont = cont + 1
            continue
            
        if i and (not b):
            aux.append(cont)
            b = True
            cont = cont + 1
            continue

        
        cont = cont + 1
    

        
    for i in aux:
        try:
            cal.append(gab[i])

        except Exception as e:
            print('ERROR IN CAL - {}'.format(e))

            print('i - {}'.format(i))
            print('aux - {}'.format(aux))
            print('gab - {}'.format(gab))
            print('cal - {}'.format(cal))
    
    
    return cal
    
def calc(closes):
    jump = 1
    L = []
    lost = []
    good = 0
    bad = 0
    perda = 0

    # corrigir numero 1, desordena o calculo dos closes
    for c in range(len(closes)):
        if c == jump:
            continue

        try:
            lucro = (closes[c])/(closes[c - 1]) - 1
            
            if lucro > 0:
                good = good + 1
            else:
                bad = bad + 1
                lost.append(lucro)
                if perda > lucro:
                    perda = lucro

            L.append(lucro)

            jump = c+1

        except Exception as e:
            print("fim do array - {}".format(e))

    # erro: total dentro do for

    total = 1
    for l in range(len(L)):
        total = total + (total * L[l])

    total = total - 1

    # taxa de acerto
    if (bad !=0) or (good != 0):
        winrate = (good/(bad+good))
    else:
        winrate = 0
    
    # multiplica pela taxa de acerto, para ter mais peso o acerto
    return total*winrate



def reward():
    rew = []
    for i in range(len(dfia.index)) :
       rew.append(calc(calculation(i)))
    return rew

def selection(rewx,x=1):
    # alterar a seleção para aceitar 20 
    rew = list(rewx)
    sel = [[0,0,0,0],[0,0,0,0]]

    lastsel = [[],[]]
    for k in range(20):
        lastsel[0].append(0)

    cont = 0
    for i in range(20):

        f = max(rew)
        if cont == 0:
            firstf = f
            cont=cont+1

        # retira zeros e substitui pela melhor
        if (firstf > f) and (f == 0):
            print('zero flag')
            if i < 4 :
                sel[0][i] = sel[0][0]
            lastsel[0][i] = lastsel[0][0]
            continue

        print(f)

        lastsel[0][i] = rew.index(f)

        if i < 4 :
            sel[0][i] = lastsel[0][i]
            sel[1][i] = (f)*100

        

        rew[rew.index(f)] = -10

    if x == 1:
        return sel
    if x == 2:
        return lastsel

def mutation(wn,s):
    global exmult
    w = []
    for i in range(len(wn[0])):
        w.append(0)

    for i in range(len(wn[0])):
        w[i] = list(dfia.loc[wn[0][i]])
        
    #criando dat aleatorio
    dat = randomwb()
 
    
    ## alterar esse trecho para um range de termos de w
    j=0
    for i in range(len(dfia.index)):
        if (j >= 15) and (j <= 19):
            dfia.loc[i] = dat

            j = j + 1
            if j >= 20:
                j=0
            
            continue
        # print('i = {}'.format(i))
        # print('j = {}'.format(j))
        dfia.loc[i] = w[j]


        j = j + 1
        if j >= 20:
            j=0
     

    aux =[]
    
    x = 0
    for i in range(len(dfia.index)):
        # adicionar um if para nao mutar todos os individuos x=1/10 == 10%
        ind1 = r.randint(0,9)
        if ind1 != 9:
            continue

        # aumenta um pouco a mutação, mais idividuos e mais genes
        aux = list(dfia.loc[i])
        nmut = 20 # numero de genes mutados nmut = 20
        used =[]
        while x < nmut:
            loc1 = r.randint(0,166)

            if loc1 in used:
                loc1 = r.randint(0,166)
            
            
            if not exmult:
                aux[loc1] =  r.uniform(-10,10)
            if exmult:
                aux[loc1] = aux[loc1] * r.uniform(-2,2)
            used.append(loc1)
            x = x + 1
        
        dfia.loc[i] = aux
        if i == 89:
            dfia.loc[i] = s
            

    return w

def delnone(mylist):
    mylist = [str(x) for x in mylist]
    ml = list(mylist)
    for i in range(len(ml)):           
        if ml[i] == 'None':
            ml[i] = 0
    ml = [float(x) for x in ml]
    return ml

def progress(v):
    vv = []
    for i in v:
        c = strategy(i,1)
        
        vv.append(c)
    
    vvv = [max(vv), vv.index(max(vv))]
    return vvv


def main():
    numg = int(input("Numero de Geracoes:"))
    gn = 0

    global df, dfia, dfout

    getdfia(1)
    print(dfia)
    gen = []
    vitoriosos =[]
    ppp =[]
    

    while gn < numg:
        
        
    
        gn = len(gen) + 1
        print('Geracao:{}'.format(gn))

        
        print('Criando Bloco . . .')

        df = block(0,0)

        print(df)

        c = 0
        fail = True
        while fail:
            if c == 0:
                fail = False
                c = c+1
            dfout = pd.DataFrame()
            dfout = getdfout()

            print('Treinando . . .')
            
            strategy()
            
            print(dfout)
            
            print('Calculando os melhores . . .')

            rew = reward()
            rew = delnone(rew)
            print(rew)

            # index das quatro melhores / lucro
            win = selection(rew)
            # index das 20 melhores: 2 -> 20 melhores
            win20 = selection(rew,2)

            # index das quatro melhores
            t = win[0]
            print('t:{}'.format(t))

            # index da melhor IA
            tbest = win[0][0]
            print('tbest:{}'.format(tbest))

            vitoriosos.append(list(dfia.loc[tbest]))     
            pp = progress(vitoriosos)
            ppp.append(pp)
            mdgen = ppp[-1]
            
            if not fail:
                cont = 0
            if (mdgen[0] <= win[1][0]) and (tbest != 89):    
                fail = False
                cont = 0
            else:
                fail = True
                vitoriosos = vitoriosos[:-1]
                ppp = ppp[:-1]
                pp = []
                log = open(doc, 'a')
                log.write("Fail: ")
                log.close()
                if cont >= 25:
                    fail = False
                cont = cont + 1


            # corrigido erro do sub, pode falhar na primeira geração
            if len(pp) > 0 or len(gen) == 0:
                try:
                    sub = vitoriosos[pp[1]]
                except:
                    sub = randomwb()

            print(mdgen,gn-1)
            
            print('Mutando . . .')
            # para não estagnar na falha

            #print(win20)
            
            if fail and (win[1][0] > win[1][1]):
                x = win20[0][0]
                for i in range(len(win20[0])):
                    win20[0][i] = x
            #print(win20)

            #mutação
            w = mutation(win20,sub)

               
        #print(w)
        gen.append(win)
        print(win)
        print()
        print()
        time.sleep(1)
        log = open(doc, 'a')
        log.write("0{}: ".format(gn - 1))
        log.write("{}\n".format(win))
        log.write("Melhor de cada: {}\n\n".format(mdgen))
        log.close()

    log = open(doc, 'a')
    log.write("Vitoriosos: {}\n".format(vitoriosos))
    log.write("Melhor de cada: {}\n\n".format(ppp))
    log.close()



    upbeep()

    

        


if __name__ == '__main__':
    main()
    print('Demorou: {}'.format(time.time() - time_inicial }}
{{$ crip-bot true }}